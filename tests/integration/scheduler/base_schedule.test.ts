import {
    getSupabaseClient,
    triggerSchedulerReplan,
    waitForReplan,
    readCurrentScenarioMetadata,
    readBaselineMetadata,
    cleanupScenarioData
} from './utils';
import { SupabaseClient } from '@supabase/supabase-js';
// Do NOT import seeding functions here
// import { cleanupAllTestData } from '../../../../simulation/scripts/db/cleanup-staging';
// import { seedBaseline } from '../../../../simulation/scripts/db/seed/baseline';
// import { seedScenario_base_schedule } from '../../../../simulation/scripts/db/seed/scenarios/base_schedule';
import { ScenarioSeedResult, BaselineRefs } from '../../../simulation/scripts/db/seed/scenarios/types'; // Still needed for the type

// Increase Jest timeout for this potentially long-running test suite
// jest.setTimeout(90000); // 90 seconds - Alternatively set globally in jest.config.js

describe('Scheduler Integration - Base Schedule', () => {
    let supabase: SupabaseClient;
    // Variables to hold metadata read from files
    let currentScenarioResult: ScenarioSeedResult;
    let baselineRefs: BaselineRefs;
    // Use a fixed technician count for consistency in tests
    const technicianCount = 4;

    beforeAll(async () => {
        supabase = getSupabaseClient();
        console.log('--- Test Setup: Reading Metadata Files --- ');
        try {
            // Read both metadata files generated by the external seeding process
            baselineRefs = await readBaselineMetadata();
            currentScenarioResult = await readCurrentScenarioMetadata();

            // Basic validation
            if (currentScenarioResult.scenarioName !== 'base_schedule') {
                throw new Error(`Expected scenario metadata for 'base_schedule', but found '${currentScenarioResult.scenarioName}'.`);
            }
            if (!currentScenarioResult.insertedIds?.jobs || currentScenarioResult.insertedIds.jobs.length === 0) {
                throw new Error('Scenario metadata is missing job IDs.');
            }
            // Get technician DB IDs from scenario results now
            const createdTechnicianDbIds = currentScenarioResult.insertedIds?.technicianDbIds ?? [];
            console.log(`Metadata loaded. Scenario: ${currentScenarioResult.scenarioName}. Techs: ${createdTechnicianDbIds.length}. Jobs: ${currentScenarioResult.insertedIds.jobs.length}`);
            console.log('--- Test Setup Complete ---');

        } catch (error) {
            console.error('FATAL: Test setup failed while reading metadata:', error);
            throw error;
        }
    }, 30000);

    it('should schedule jobs correctly according to the base scenario after replan', async () => {
        // Ensure setup succeeded and we have metadata
        expect(baselineRefs).toBeDefined();
        expect(currentScenarioResult).toBeDefined();
        expect(currentScenarioResult.insertedIds.jobs).toBeDefined();
        expect(currentScenarioResult.insertedIds.technicianDbIds).toBeDefined(); // Check scenario DB techs IDs

        const scenarioJobIds = currentScenarioResult.insertedIds.jobs!;
        // Get valid technician DB IDs from scenario results
        const validTechnicianDbIds = currentScenarioResult.insertedIds.technicianDbIds!;

        console.log('Triggering scheduler replan...');
        await triggerSchedulerReplan();

        console.log('Waiting for replan to complete...');
        const checkCondition = async (): Promise<boolean> => {
            const { data: jobs, error } = await supabase
                .from('jobs')
                .select('id') // Only need to count the matching rows
                .in('id', scenarioJobIds)
                // Wait for both assignment and estimated schedule
                .not('assigned_technician', 'is', null) 
                .not('estimated_sched', 'is', null);

            if (error) {
                console.error('DB query error during wait:', error);
                return false;
            }
            const allJobsScheduled = jobs !== null && jobs.length === scenarioJobIds.length;
            if (allJobsScheduled) {
                console.log(`Condition met: All ${scenarioJobIds.length} expected jobs have assignment and estimated schedule.`);
            } else {
                console.log(`Condition not met: Found ${jobs?.length ?? 0} jobs with assignment/schedule, expected ${scenarioJobIds.length}.`);
            }
            return allJobsScheduled;
        };
        // Give it potentially more time as we wait for full scheduling
        await waitForReplan(checkCondition, 90000, 4000); 

        console.log('Replan complete. Verifying schedule...');

        // Fetch final state (this query was already correct)
        const { data: scheduledJobs, error: jobsError } = await supabase
            .from('jobs')
            .select('*, orders(*)') 
            .in('id', scenarioJobIds)
            .order('estimated_sched', { ascending: true });

        expect(jobsError).toBeNull();
        expect(scheduledJobs).not.toBeNull();
        expect(scheduledJobs!.length).toEqual(scenarioJobIds.length);

        // Assertions were already correct for the final state
        for (const job of scheduledJobs!) {
            expect(job.status).toEqual('queued'); // Status should still be queued
            expect(job.estimated_sched).not.toBeNull();
            expect(job.assigned_technician).not.toBeNull();
            // Use the numeric DB IDs for the check
            expect(validTechnicianDbIds).toContain(job.assigned_technician);
        }

        console.log('Base schedule verification successful.');
    });

    afterAll(async () => {
        // Cleanup data created by this scenario run
        if (currentScenarioResult && currentScenarioResult.insertedIds) {
            console.log('--- Test Teardown: Cleaning up scenario data ---');
            await cleanupScenarioData(currentScenarioResult.insertedIds);
        } else {
            console.log('--- Test Teardown: No scenario metadata found, skipping cleanup --- ');
        }
    });
}); 