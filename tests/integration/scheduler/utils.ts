import { SupabaseClient, createClient } from '@supabase/supabase-js';
import fs from 'fs/promises';
import path from 'path';
// Import the type definitions
import { ScenarioSeedResult, BaselineRefs } from '../../../simulation/scripts/db/seed/scenarios/types';

// Define the paths to the temporary metadata files
const BASELINE_METADATA_PATH = path.resolve(__dirname, '../.baseline-metadata.json');
const CURRENT_SCENARIO_METADATA_PATH = path.resolve(__dirname, '../.current-scenario-metadata.json');

// Path to the metadata file generated by generate-metadata.ts -> No longer needed
// const METADATA_PATH = path.resolve(__dirname, '../../../../simulation/scripts/db/seed/seed-metadata.json');
// TODO: Get from environment variables
const SCHEDULER_API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000/api';
const STAGING_SUPABASE_URL = process.env.STAGING_SUPABASE_URL;
const STAGING_SUPABASE_ANON_KEY = process.env.STAGING_SUPABASE_ANON_KEY;

let supabase: SupabaseClient | null = null;

/**
 * Gets the Supabase client instance for the Staging environment.
 * Initializes it if it doesn't exist.
 */
export function getSupabaseClient(): SupabaseClient {
    if (!STAGING_SUPABASE_URL || !STAGING_SUPABASE_ANON_KEY) {
        throw new Error('Staging Supabase URL or Anon Key is not configured in environment variables.');
    }
    if (!supabase) {
        supabase = createClient(STAGING_SUPABASE_URL, STAGING_SUPABASE_ANON_KEY);
    }
    return supabase;
}

/**
 * Reads the baseline metadata from the temporary file.
 * This file should be generated by the seeding script (index.ts baseline action).
 */
export async function readBaselineMetadata(): Promise<BaselineRefs> {
    try {
        const data = await fs.readFile(BASELINE_METADATA_PATH, 'utf-8');
        // TODO: Add validation (e.g., Zod) to ensure structure matches BaselineRefs
        const metadata = JSON.parse(data) as BaselineRefs;
        // Basic validation
        if (!metadata.technicianIds) {
            throw new Error('Baseline metadata file content is invalid or missing technicianIds.');
        }
        logInfo(`Read baseline metadata from ${BASELINE_METADATA_PATH}.`);
        return metadata;
    } catch (error) {
        console.error(`Error reading baseline metadata file at ${BASELINE_METADATA_PATH}:`, error);
        throw new Error(`Failed to read or parse baseline metadata: ${error.message}. Ensure the baseline seeding script ran successfully and generated the file.`);
    }
}

/**
 * Reads the metadata for the currently seeded scenario from the temporary file.
 * This file should be generated by the seeding script (index.ts scenario action).
 */
export async function readCurrentScenarioMetadata(): Promise<ScenarioSeedResult> {
    try {
        const data = await fs.readFile(CURRENT_SCENARIO_METADATA_PATH, 'utf-8');
        const metadata = JSON.parse(data) as ScenarioSeedResult;
        if (!metadata.scenarioName || !metadata.insertedIds) {
            throw new Error('Current scenario metadata file content is invalid or missing required fields.');
        }
        logInfo(`Read metadata for scenario: ${metadata.scenarioName} from ${CURRENT_SCENARIO_METADATA_PATH}.`);
        return metadata;
    } catch (error) {
        console.error(`Error reading current scenario metadata file at ${CURRENT_SCENARIO_METADATA_PATH}:`, error);
        throw new Error(`Failed to read or parse current scenario metadata: ${error.message}. Ensure the scenario seeding script ran successfully and generated the file.`);
    }
}

/**
 * Triggers the scheduler's replan process via API.
 */
export async function triggerSchedulerReplan(): Promise<Response> {
    console.log(`Triggering scheduler replan at ${SCHEDULER_API_URL}/scheduler/run-replan...`);
    try {
        const response = await fetch(`${SCHEDULER_API_URL}/scheduler/run-replan`, {
            method: 'POST',
            // Add headers/body if required by the API
        });
        console.log(`Scheduler replan trigger response status: ${response.status}`);
        if (!response.ok) {
            const errorBody = await response.text();
            console.error(`Scheduler API error: ${response.status} ${response.statusText}`, errorBody);
            throw new Error(`Scheduler API request failed: ${response.status} ${response.statusText}`);
        }
        return response;
    } catch (error) {
        console.error('Error triggering scheduler replan:', error);
        throw error;
    }
}

/**
 * Polls the database to wait for the replan process to complete.
 * This is a basic implementation and might need refinement based on how completion is determined.
 *
 * @param checkCondition Function that returns true when the condition is met.
 * @param timeout Max time to wait in milliseconds.
 * @param interval Poll interval in milliseconds.
 */
export async function waitForReplan(
    checkCondition: () => Promise<boolean>,
    timeout = 30000, // 30 seconds timeout
    interval = 2000   // Check every 2 seconds
): Promise<void> {
    const startTime = Date.now();
    while (Date.now() - startTime < timeout) {
        console.log('Checking replan completion condition...');
        if (await checkCondition()) {
            console.log('Replan completion condition met.');
            return;
        }
        await new Promise(resolve => setTimeout(resolve, interval));
    }
    throw new Error(`Timeout waiting for replan completion after ${timeout / 1000} seconds.`);
}

/**
 * Cleans up test data based on scenario metadata.
 * Placeholder - Implementation depends on metadata structure and cleanup strategy.
 * @param scenarioName The name of the scenario whose data needs cleanup.
 */
export async function cleanupTestData(scenarioName: string): Promise<void> {
    // const metadata = await readScenarioMetadata();
    // const scenarioData = metadata[scenarioName];
    // if (!scenarioData || !scenarioData.insertedIds) {
    //     console.warn(`No metadata or insertedIds found for scenario ${scenarioName}. Skipping cleanup.`);
    //     return;
    // }
    //
    // const client = getSupabaseClient();
    // console.log(`Cleaning up data for scenario: ${scenarioName}`);
    //
    // // Example: Iterate through tables and delete records by ID
    // for (const tableName in scenarioData.insertedIds) {
    //     const ids = scenarioData.insertedIds[tableName];
    //     if (ids && ids.length > 0) {
    //         console.log(`Deleting ${ids.length} records from ${tableName}...`);
    //         const { error } = await client
    //             .from(tableName)
    //             .delete()
    //             .in('id', ids); // Assuming 'id' is the primary key
    //         if (error) {
    //             console.error(`Error cleaning up ${tableName}:`, error);
    //             // Decide whether to throw or just log
    //         }
    //     }
    // }
    console.warn(`Cleanup function for scenario ${scenarioName} is not fully implemented.`);
    // Actual implementation depends heavily on the structure of seed-metadata.json
    // and how reliably we can track created records. For now, manual cleanup or
    // full DB reset between test runs might be necessary.
}

// Add other necessary utility functions as needed 

// Add logInfo helper if not already present
function logInfo(message: string) {
    console.log(`[INFO] ${message}`);
} 