import { SupabaseClient, createClient } from '@supabase/supabase-js';
import * as fs from 'fs/promises';
import * as path from 'path';
// Import the type definitions
import { ScenarioSeedResult, BaselineRefs } from '../../../simulation/scripts/db/seed/scenarios/types';
// Import Zod
import { z } from 'zod';

// Define Zod schemas matching the types
const BaselineRefsSchema = z.object({
    customerIds: z.array(z.string().uuid()).optional(),
    addressIds: z.array(z.number().int()).optional(),
    customerVehicleIds: z.array(z.number().int()).optional(),
    serviceIds: z.array(z.number().int()).optional(),
    equipmentIds: z.array(z.number().int()).optional(),
    vanIds: z.array(z.number().int()).optional(),
    ymmIds: z.array(z.number().int()).optional(),
    technicianDefaultHoursIds: z.array(z.number().int()).optional(),
    technicianAvailabilityExceptionIds: z.array(z.number().int()).optional(),
});

const ScenarioSeedResultSchema = z.object({
    scenarioName: z.string().min(1, 'Scenario name cannot be empty'),
    insertedIds: z.record(
        z.string(),
        z.array(z.union([z.number().int(), z.string().uuid()])).optional()
    ).and(z.object({
        orders: z.array(z.number().int()).optional(),
        jobs: z.array(z.number().int()).optional(),
        equipment: z.array(z.number().int()).optional(),
        technician_availability_exceptions: z.array(z.number().int()).optional(),
        technicianIds: z.array(z.string().uuid()).optional(),
        technicianDbIds: z.array(z.number().int()).optional(),
        vanIds: z.array(z.number().int()).optional()
    })),
});

// Define the paths to the temporary metadata files
const BASELINE_METADATA_PATH = path.resolve(__dirname, '../.baseline-metadata.json');
const CURRENT_SCENARIO_METADATA_PATH = path.resolve(__dirname, '../.current-scenario-metadata.json');

// Path to the metadata file generated by generate-metadata.ts -> No longer needed
// const METADATA_PATH = path.resolve(__dirname, '../../../../simulation/scripts/db/seed/seed-metadata.json');
// TODO: Get from environment variables or make configurable
// const SCHEDULER_API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000/api'; // Web app proxy URL
const SCHEDULER_HOST_URL = 'http://localhost:3001'; // Target scheduler directly based on .env.test intention
const SUPABASE_URL = process.env.SUPABASE_URL;
const SUPABASE_ANON_KEY = process.env.SUPABASE_ANON_KEY;

let supabase: SupabaseClient | null = null;

/**
 * Gets the Supabase client instance for the Staging environment.
 * Initializes it if it doesn't exist.
 */
export function getSupabaseClient(): SupabaseClient {
    if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
        throw new Error('Staging Supabase URL or Anon Key is not configured in environment variables.');
    }
    if (!supabase) {
        supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    }
    return supabase;
}

/**
 * Reads the baseline metadata from the temporary file.
 * This file should be generated by the seeding script (index.ts baseline action).
 */
export async function readBaselineMetadata(): Promise<BaselineRefs> {
    try {
        const data = await fs.readFile(BASELINE_METADATA_PATH, 'utf-8');
        const jsonData = JSON.parse(data);
        // Validate the parsed JSON against the Zod schema
        const metadata = BaselineRefsSchema.parse(jsonData);
        logInfo(`Successfully validated and read baseline metadata from ${BASELINE_METADATA_PATH}.`);
        return metadata as BaselineRefs;
    } catch (error) {
        console.error(`Error reading or validating baseline metadata file at ${BASELINE_METADATA_PATH}:`, error);
        if (error instanceof z.ZodError) {
            throw new Error(`Baseline metadata validation failed: ${JSON.stringify(error.errors)}`);
        }
        // Add type check for error message access
        const errorMessage = error instanceof Error ? error.message : String(error);
        throw new Error(`Failed to read or parse baseline metadata: ${errorMessage}. Ensure the baseline seeding script ran successfully and generated the file.`);
    }
}

/**
 * Reads the metadata for the currently seeded scenario from the temporary file.
 * This file should be generated by the seeding script (index.ts scenario action).
 */
export async function readCurrentScenarioMetadata(): Promise<ScenarioSeedResult> {
    try {
        const data = await fs.readFile(CURRENT_SCENARIO_METADATA_PATH, 'utf-8');
        const jsonData = JSON.parse(data);
        // Validate the parsed JSON against the Zod schema
        const metadata = ScenarioSeedResultSchema.parse(jsonData);
        logInfo(`Successfully validated and read metadata for scenario: ${metadata.scenarioName} from ${CURRENT_SCENARIO_METADATA_PATH}.`);
        return metadata as ScenarioSeedResult;
    } catch (error) {
        console.error(`Error reading or validating current scenario metadata file at ${CURRENT_SCENARIO_METADATA_PATH}:`, error);
        if (error instanceof z.ZodError) {
            throw new Error(`Scenario metadata validation failed: ${JSON.stringify(error.errors)}`);
        }
        // Add type check for error message access
        const errorMessage = error instanceof Error ? error.message : String(error);
        throw new Error(`Failed to read or parse current scenario metadata: ${errorMessage}. Ensure the scenario seeding script ran successfully and generated the file.`);
    }
}

/**
 * Triggers the scheduler's replan process via API.
 */
export async function triggerSchedulerReplan(): Promise<Response> {
    // Target the scheduler service directly on its exposed host port
    const targetUrl = `${SCHEDULER_HOST_URL}/run-replan`;
    console.log(`Triggering scheduler replan directly at ${targetUrl}...`);
    try {
        const response = await fetch(targetUrl, {
            method: 'POST',
            headers: {
                 // Add content type even if body is empty for some frameworks
                'Content-Type': 'application/json' 
            },
            // Add empty body if required by the endpoint
            // body: JSON.stringify({})
        });
        console.log(`Scheduler replan trigger response status: ${response.status}`);
        if (!response.ok) {
            const errorBody = await response.text();
            console.error(`Scheduler API error: ${response.status} ${response.statusText}`, errorBody);
            throw new Error(`Scheduler API request failed: ${response.status} ${response.statusText}`);
        }
        return response;
    } catch (error) {
        console.error('Error triggering scheduler replan directly:', error);
        throw error;
    }
}

/**
 * Polls the database to wait for the replan process to complete.
 * This is a basic implementation and might need refinement based on how completion is determined.
 *
 * @param checkCondition Function that returns true when the condition is met.
 * @param timeout Max time to wait in milliseconds.
 * @param interval Poll interval in milliseconds.
 */
export async function waitForReplan(
    checkCondition: () => Promise<boolean>,
    timeout = 30000, // 30 seconds timeout
    interval = 2000   // Check every 2 seconds
): Promise<void> {
    const startTime = Date.now();
    while (Date.now() - startTime < timeout) {
        console.log('Checking replan completion condition...');
        if (await checkCondition()) {
            console.log('Replan completion condition met.');
            return;
        }
        await new Promise(resolve => setTimeout(resolve, interval));
    }
    throw new Error(`Timeout waiting for replan completion after ${timeout / 1000} seconds.`);
}

/**
 * Cleans up specific test data created by a scenario run, based on the provided IDs.
 * Focuses on deleting transactional data like jobs, orders, and exceptions.
 * Ensures deletion order respects foreign key constraints.
 * @param insertedIds An object containing arrays of IDs for records created by the scenario.
 */
export async function cleanupScenarioData(insertedIds: ScenarioSeedResult['insertedIds']): Promise<void> {
    const supabase = getSupabaseClient(); // Get client instance
    logInfo(`--- Starting Scenario Data Cleanup for Scenario: ${JSON.stringify(insertedIds)} ---`);
    let errorOccurred = false;

    // Define deletion order (dependents first)
    const deletionOrder: (keyof ScenarioSeedResult['insertedIds'])[] = [
        'technician_availability_exceptions', // Depends on technicians
        'jobs', // Depends on orders, services, technicians, addresses
        // 'order_services', // If scenarios modify this junction table
        // 'order_uploads', // If scenarios create uploads
        'orders', // Depends on users, vehicles, addresses
        'equipment' // If scenarios create equipment
    ];

    for (const tableName of deletionOrder) {
        const idsToDelete = insertedIds[tableName];
        
        // Check if the key exists and the array has IDs
        if (idsToDelete && idsToDelete.length > 0) {
             // Ensure IDs are numbers for tables with numeric PKs
             if (tableName !== 'technicianIds') { // technicianIds are UUID strings
                const numericIds = idsToDelete.filter((id): id is number => typeof id === 'number' && !isNaN(id));
                if (numericIds.length > 0) {
                    logInfo(`Attempting to delete ${numericIds.length} record(s) from ${tableName} with IDs: [${numericIds.join(', ')}]`);
                    // Only destructure error, as data is unused
                    const { error } = await supabase
                        .from(tableName as string)
                        .delete()
                        .in('id', numericIds);

                    if (error) {
                        logError(`Error deleting data from ${tableName}:`, error);
                        errorOccurred = true;
                        // Decide whether to continue or stop on error
                        // break; 
                    } else {
                        // Log success without assuming data is returned
                        logInfo(`Successfully deleted records from ${tableName}.`); 
                    }
                }
             } else {
                 logInfo(`Skipping deletion for ${tableName} as it contains non-numeric IDs (likely auth IDs).`);
             }
        }
    }

    if (errorOccurred) {
        logError('Scenario cleanup finished with errors.', null);
    } else {
        logInfo('--- Scenario Data Cleanup Finished Successfully ---');
    }
}

// Add other necessary utility functions as needed 

// Add logInfo helper if not already present
function logInfo(message: string) {
    console.log(`[INFO] ${message}`);
}

function logError(message: string, error: any) {
    console.error(`[ERROR] ${message}`, error);
}

/**
 * Retrieves the Technician Auth ID (UUID string) corresponding to a given Technician DB ID
 * from the scenario metadata.
 *
 * Assumes that technicianDbIds and technicianAuthIds arrays in insertedIds are ordered consistently.
 *
 * @param scenarioResult The result object from readCurrentScenarioMetadata.
 * @param techDbId The numeric Technician DB ID.
 * @returns The corresponding Technician Auth ID (UUID string).
 * @throws Error if the DB ID is not found or metadata is missing/malformed.
 */
export function getTechnicianAuthIdByDbId(scenarioResult: ScenarioSeedResult, techDbId: number): string {
    const dbIds = scenarioResult.insertedIds?.technicianDbIds;
    const authIds = scenarioResult.insertedIds?.technicianAuthIds;

    if (!dbIds || !authIds || dbIds.length !== authIds.length) {
        throw new Error('Scenario metadata is missing technicianDbIds or technicianAuthIds, or arrays have different lengths.');
    }

    const index = dbIds.findIndex(id => id === techDbId);
    if (index === -1) {
        throw new Error(`Technician DB ID ${techDbId} not found in scenario metadata technicianDbIds: [${dbIds.join(', ')}]`);
    }

    const authId = authIds[index];
    if (typeof authId !== 'string') { // Basic type check for UUID
        throw new Error(`Invalid Auth ID found at index ${index} for DB ID ${techDbId}. Expected string, got ${typeof authId}`);
    }

    return authId;
}

/**
 * Retrieves the Assigned Van ID (number) corresponding to a given Technician DB ID
 * from the scenario metadata.
 *
 * Assumes that technicianDbIds and assignedVanIds arrays in insertedIds are ordered consistently.
 *
 * @param scenarioResult The result object from readCurrentScenarioMetadata.
 * @param techDbId The numeric Technician DB ID.
 * @returns The corresponding Assigned Van ID (number).
 * @throws Error if the DB ID is not found or metadata is missing/malformed.
 */
export function getAssignedVanIdByDbId(scenarioResult: ScenarioSeedResult, techDbId: number): number {
    const dbIds = scenarioResult.insertedIds?.technicianDbIds;
    // NOTE: Logic in seed/index.ts currently puts assignedVanIds in an object map, not an array.
    // Need to adapt or ensure seed/index.ts puts it in an array matching dbIds order.
    // Assuming for now it's an array matching dbIds order, like authIds.
    const vanIds = scenarioResult.insertedIds?.assignedVanIds as number[] | undefined; // Assuming array for now

    if (!dbIds || !vanIds || dbIds.length !== vanIds.length) {
        throw new Error('Scenario metadata is missing technicianDbIds or assignedVanIds, or arrays have different lengths.');
    }

    const index = dbIds.findIndex(id => id === techDbId);
    if (index === -1) {
        throw new Error(`Technician DB ID ${techDbId} not found in scenario metadata technicianDbIds: [${dbIds.join(', ')}]`);
    }

    const vanId = vanIds[index];
     if (typeof vanId !== 'number') { // Basic type check
        throw new Error(`Invalid Van ID found at index ${index} for DB ID ${techDbId}. Expected number, got ${typeof vanId}`);
    }

    return vanId;
} 