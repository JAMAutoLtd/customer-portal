Product Requirements Document: Robust Handling of Fixed Technician Unavailability

1. Introduction
----------------

1.1. Problem Statement:
Our current scheduling system faces challenges in reliably handling fixed periods of technician unavailability, particularly those stemming from 'locked' jobs (e.g., 'en_route', 'in_progress') and database-defined exceptions (e.g., time off). While the scheduler module (`apps/scheduler/`) correctly calculates the resulting gaps in a technician's availability, this information is not effectively communicated to or enforced by the optimization module (`apps/optimiser/`). This leads to the optimizer scheduling new jobs during these periods of known unavailability, resulting in incorrect schedules, operational inefficiencies, and failing integration tests (e.g., `locked_job_impact.test.ts`).

1.2. Goal:
To implement a robust, cohesive, and efficient system for modeling and enforcing all types of fixed-time technician unavailability within the optimizer. This includes unavailability due to:
    a. Jobs in 'locked' states (e.g., 'en_route', 'in_progress') with a defined `estimated_sched` for the current planning day.
    b. Technician availability exceptions defined in the database (e.g., approved time off, custom non-working hours).
The solution should ensure that the optimizer treats these unavailability periods as immutable constraints, scheduling other work strictly around them.

1.3. Scope:
    - This PRD covers modifications to the scheduler (`apps/scheduler/`) for payload generation and the optimizer (`apps/optimiser/`) for constraint interpretation and enforcement.
    - It focuses on *fixed* blocks of unavailability. Flexible breaks (e.g., "lunch between 12-2 PM") are out of scope for this specific PRD but the solution should be mindful of future compatibility.

1.4. Glossary:
    - **Locked Job:** A job that is currently being actioned (e.g., status 'en_route', 'in_progress') and has an `estimated_sched`, making the assigned technician unavailable for other tasks during its duration plus travel.
    - **DB Exception:** A period of unavailability defined in the database (e.g., `technician_availability_exceptions` table).
    - **Dummy Break Item:** An `OptimizationItem` created by the scheduler to represent a period of fixed unavailability. This is not a real job but a modeling construct.
    - **Fixed Constraint:** An `OptimizationFixedConstraint` that specifies an exact start time and duration for an `OptimizationItem`.
    - **Scheduler:** The service responsible for preparing data for optimization (`apps/scheduler/`).
    - **Optimizer:** The service responsible for solving the VRP (`apps/optimiser/`).
    - **Availability Gap:** A period within a technician's shift when they are not available to perform new jobs.

2. Current System Analysis (Brief)
---------------------------------

2.1. `fixed_time` Jobs:
Jobs explicitly marked with `status: 'fixed_time'` and a `fixed_schedule_time` are generally handled by setting an `isFixedTime = true` flag and `fixedTimeISO` on their `OptimizationItem` in the payload. The optimizer then applies a `SetRange(start, start)` constraint to their node, effectively fixing their start time. This mechanism appears largely functional.

2.2. Locked Jobs & DB Exceptions:
The scheduler (`apps/scheduler/src/scheduler/availability.ts`) correctly calculates non-contiguous availability windows for technicians by considering locked jobs and DB exceptions. It identifies the resulting "gaps."
The scheduler (`apps/scheduler/src/scheduler/payload.ts`) then attempts to model these gaps by:
    a. Creating "dummy break items" (`OptimizationItem` with IDs like `break_{techId}_{index}`).
    b. Creating corresponding `OptimizationFixedConstraint`s for these dummy items.
However, a key failure point has been identified: the optimizer (`apps/optimiser/main.py`) does not currently recognize or correctly apply the fixed constraints specifically to these `break_...` items. The constraints are effectively ignored for these dummy items.

3. Proposed Solution: "Robust Dummy Break Item Enforcement"
--------------------------------------------------------

This solution refines and correctly implements the existing "dummy break item" strategy. The core principle is to treat all fixed unavailability periods as mandatory, zero-travel-time, fixed-duration "tasks" (represented by dummy break items) that the specifically assigned technician *must* conceptually "perform" at the exact specified time.

4. Detailed Requirements
------------------------

4.1. Scheduler-Side Modifications (`apps/scheduler/src/scheduler/payload.ts` and related utilities):

    4.1.1. **Dedicated Dummy Break Location:**
        a.  A single, global dummy `OptimizationLocation` shall be defined and consistently used for all dummy break items.
            - ID: `'dummy_break_loc'` (or similar constant).
            - Coordinates: Arbitrary (e.g., `{ lat: -999, lng: -999 }`) as travel time will be zero.
        b.  This dummy location shall be added to the `payload.locations` array sent to the optimizer.
        c.  Its `locationIndex` must be tracked for use in dummy break items and travel matrix adjustments.

    4.1.2. **Travel Time Matrix Modification:**
        a.  After the `travelTimeMatrix` is computed (e.g., by `getBulkTravelTimes`), it must be modified.
        b.  Travel time *to* the `dummy_break_loc` index *from* all other locations (including other dummy break locations, if multiple were used, though one is recommended) shall be set to 0.
        c.  Travel time *from* the `dummy_break_loc` index *to* all other locations shall be set to 0.

    4.1.3. **Dummy Break Item (`OptimizationItem`) Generation:**
        a.  For each availability gap identified (from `findAvailabilityGaps` which processes outputs of `applyLockedJobsToWindows` and `calculateWindowsForTechnician`):
            i.  Generate a unique `OptimizationItem.id` (e.g., `break_{techId}_{gapIndex}`).
            ii. Set `OptimizationItem.locationIndex` to the index of the `'dummy_break_loc'`.
            iii.Set `OptimizationItem.durationSeconds` to the calculated duration of the gap.
            iv. Set `OptimizationItem.eligibleTechnicianIds = [tech.id]` where `tech.id` is the technician for whom the gap applies.
            v.  If the `OptimizationItem` model includes a field like `serviceTimeSeconds`, it should be set equal to `durationSeconds` for break items. This makes the "service" at the dummy node occupy the entire break duration.
            vi. `earliestStartTimeISO` is not strictly necessary for these items as their time will be fixed by an `OptimizationFixedConstraint`.
        b.  All generated dummy break items shall be added to the `payload.items` array.

    4.1.4. **Fixed Constraint (`OptimizationFixedConstraint`) Generation for Dummy Breaks:**
        a.  For each dummy break item generated:
            i.  Create an `OptimizationFixedConstraint`.
            ii. `itemId` must match the ID of the corresponding dummy break item.
            iii.`fixedTimeISO` must be the absolute UTC start time of the availability gap.
            iv. `durationSeconds` must be the duration of the availability gap.
            v.  `assignedTechnicianId` must be the `id` of the technician the break applies to.
        b.  All such generated fixed constraints shall be added to the `payload.fixedConstraints` array.

4.2. Optimizer-Side Modifications (`apps/optimiser/main.py`):

    4.2.1. **Pre-computation:**
        a.  Maintain the existing `fixed_constraints_map = {fc.itemId: fc for fc in payload.fixedConstraints}` for efficient lookup.

    4.2.2. **Constraint Application Logic:**
        The main loop processing `payload.items` to apply constraints needs to differentiate between regular items and dummy break items.
        a.  **Identify Dummy Break Items:** Check if `item.id.startswith('break_')`.
        b.  **For Dummy Break Items:**
            i.  Retrieve the corresponding `constraint` from `fixed_constraints_map` using `item.id`.
            ii. If the constraint exists and `constraint.assignedTechnicianId` matches the technician associated with the current vehicle being processed by the optimizer (or if applying constraints globally before vehicle-specific logic, this check is implicit if eligibility is handled later):
                1.  Calculate `break_start_seconds_rel = iso_to_seconds(constraint.fixedTimeISO) - planning_epoch_seconds`.
                2.  Calculate `break_end_seconds_rel = break_start_seconds_rel + constraint.durationSeconds`.
                3.  Apply the fixed time constraint to the break item's node:
                    `time_dimension.CumulVar(solver_index_for_break_item).SetRange(break_start_seconds_rel, break_end_seconds_rel)`
                4.  **Mandatory Performance:** To ensure the break item is "performed" by the assigned technician if that technician's route is used, add:
                    `routing.AddDisjunction([solver_index_for_break_item], 0)`
                    (This adds a disjunction with a penalty of 0, meaning it *must* be included in the solution if possible for the vehicle visiting nodes in that disjunction list - here, only the break node itself. This makes it mandatory for the route that includes this node.)
            iii.Log clearly when break constraints are applied.
        c.  **For Regular Fixed Jobs (not breaks):**
            i.  Identify these (e.g., `item.id in fixed_constraints_map and not item.id.startswith('break_')` OR an `item.isFixedTime == true` flag if that convention is also used for non-break fixed items).
            ii. Apply `time_dimension.CumulVar(solver_index_for_job).SetRange(fixed_job_start_rel, fixed_job_start_rel)` (start time fixed, duration is handled by service time at the node).
            iii.Ensure these are also made mandatory via `routing.AddDisjunction([solver_index_for_job], 0)`.
        d.  **For Regular Schedulable Items (not fixed, not breaks):**
            i.  Apply `earliestStartTimeISO` constraints as `time_dimension.CumulVar(solver_index).SetMin(earliest_start_rel)`.
            ii. Apply standard disjunctions with appropriate penalties: `routing.AddDisjunction([solver_index], penalty_value)`.

    4.2.3. **Technician Eligibility for Breaks:**
        a.  The scheduler sets `eligibleTechnicianIds = [tech.id]` for each break item.
        b.  The optimizer's general mechanism for enforcing item eligibility (e.g., using `routing.VehicleVar(item_index).SetValues([...allowed_vehicle_indices...])` or by manipulating arc costs for non-eligible vehicles) must ensure that only the assigned technician can "visit" or be routed through the `solver_index` of their specific break item. This is critical. If no such general mechanism exists, it needs to be added or specifically handled for break items.

    4.2.4. **Result Processing:**
        a.  When constructing the final list of `RouteStop`s for each vehicle's route from the optimizer's solution, items whose IDs start with `'break_'` must be filtered out. They are modeling constructs and not actual jobs to be reported to the end-user or consuming systems.

4.3. Interaction with Other Constraints:

    4.3.1. **Technician Overall Workday:** The overall `earliestStartTimeISO` and `latestEndTimeISO` for a technician (applied to `routing.Start(vehicle_index)` and `routing.End(vehicle_index)`) will still define the absolute boundaries of their shift. Dummy breaks will carve out unavailable periods *within* these boundaries.

    4.3.2. **`fixed_assignment` (Job to Tech, not Time):** This remains an eligibility constraint. If a job is fixed-assigned but not fixed-time, it will be routed to the correct tech. If that tech has breaks, the job will be scheduled around them.

5. Testing and Validation
-------------------------
A comprehensive test suite is required:
    a.  Re-validate and ensure `tests/integration/scheduler/locked_job_impact.test.ts` passes.
    b.  New tests for unavailability from DB exceptions:
        i.  Full day off for a technician.
        ii. Partial day off (e.g., morning only).
        iii.Multiple distinct unavailability blocks for a single tech on the same day.
    c.  Scenarios where a break is at the very start or end of a technician's shift.
    d.  Scenarios with no actual schedulable jobs but technicians have defined breaks (ensure correct empty/no-op routes are generated).
    e.  Scenarios with multiple technicians, each having different break/unavailability patterns.
    f.  Verify travel times are not affected by the presence of dummy break items.

6. Out of Scope (Future Considerations)
---------------------------------------
    a.  Modeling flexible breaks (e.g., "30-minute lunch between 12 PM and 2 PM") using OR-Tools features like `SetBreakIntervalsOfVehicle`. The current PRD focuses solely on *fixed, non-negotiable* unavailability periods.
    b.  Dynamic changes to breaks once optimization has begun (this PRD assumes breaks are known at the start of the optimization pass).

7. References
-------------
    - Internal JIRA/Issue Tracker: [Link to relevant ticket(s) if any]
    - Previous Gemini AI Discussion Logs/Snippets (relevant excerpts can be appended or linked)
    - Relevant file paths:
        - `apps/scheduler/src/scheduler/payload.ts`
        - `apps/scheduler/src/scheduler/availability.ts`
        - `apps/scheduler/src/services/maps/google.ts` (or equivalent for travel matrix)
        - `apps/scheduler/src/types/optimization.types.ts`
        - `apps/optimiser/main.py`
        - `apps/optimiser/models.py`
    - OR-Tools documentation regarding Time Windows, Disjunctions, and `CumulVar.SetRange`.

This PRD outlines a path to a more reliable scheduling system by ensuring all fixed unavailability is correctly modeled and strictly enforced by the optimizer. 